---
title: '杂项知识'
date: 2022-9-10 15:30:00
permalink: '/posts/blogs/杂项知识'
isTimeLine: true
# sidebar: auto
# sidebarDepth: 1
category:
 - 我的前端路线
tag:
 - React
 - 文件操作
 - javascript
 - css
# isShowComments: false
# publish: true
icon: pen-to-square
star: true
sticky: true
---


### 文件下载(iframe、a)

```js
const getAwardStudentTemplate = () => {
    exportAwardStudentsList({}).then((res) => {
      if(res.data.Data !== null) {
        const a = document.createElement('a'); // a标签导出下载
        a.href = res.data.Data.DownloadUrl;
        a.click();
        a.remove();
      }
    })
    getImportFileTemplate({ params: { TabName: 'AwardA' } }).then((res) => {
      if (res.data.Data !== null) {
        let downloadUrl2 = res.data.Data.DownloadUrl;
        let iframe = document.createElement('iframe'); // iframe导出下载
        iframe.id = 'iframe2';
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
        iframe.src = downloadUrl2;
      }
    })
  }
```

#### 自定义文件下载名

* 直接使用a标签下载可能会出现无法自定义a标签直接给download不生效

```js
const link = document.createElement('a')
const body = document.querySelector('body')

link.href = window.URL.createObjectURL(blob)
link.download = filename

// fix Firefox
link.style.display = 'none'
body?.appendChild(link)

link.click()
body?.removeChild(link)

window.URL.revokeObjectURL(link.href)
```

* 借用XMLHttpRequest将url转接成blob流下载，自定义文件名

```js
// 1. 
this.getBlob(res.data.Data.DownloadUrl).then((res) => {
  this.saveAs(res, '评奖记录列表.xlsx');
});

getBlob(url: string) {
  return new Promise((resolve, err) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'blob';
    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(xhr.response);
      }
    }
    xhr.send();
  })
}

saveAs(blob: any, filename: any) {
  const link = document.createElement('a')
  const body = document.querySelector('body')

  link.href = window.URL.createObjectURL(blob)
  link.download = filename

  // fix Firefox
  link.style.display = 'none'
  body?.appendChild(link)

  link.click()
  body?.removeChild(link)

  window.URL.revokeObjectURL(link.href)
}
  
// 2.直接转blob后下载
const handleDownload = (url: string, filename: string) => {
  const x = new window.XMLHttpRequest();
  x.open('GET', url, true);
  x.responseType = 'blob';
  x.onload = () => {
    const url = window.URL.createObjectURL(x.response);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
  };
  x.send();
}
```



### upload文件accept限制

**上传组件时，不是直接上传后缀名，而是文件后缀（扩展名）对应有MIME类型，方便iis中或其他服务器对相应的文件进行解析。有些文件的后缀名没有默认解析就出现上传后无法访问或者下载的问题，这个时候就要设置文件后缀对应的MIME类型，设置后才能访问或者下载**

```
后缀名        　　MIME名称
*.3gpp　　 　　 audio/3gpp, video/3gpp
*.ac3　　　　    audio/ac3
*.asf 　　　　    allpication/vnd.ms-asf
*.au 　　　　    audio/basic
*.css 　　　　  text/css
*.csv  　　　　 text/csv
*.doc 　　　　 application/msword
*.docx        application/vnd.openxmlformats-officedocument.wordprocessingml.document
*.dot　　　　   application/msword
*.dtd　　　　   application/xml-dtd
*.dwg　　　     image/vnd.dwg
*.dxf　　　　   image/vnd.dxf
*.gif　　　　    image/gif
*.htm　　　　  text/html
*.html　　　　 text/html
*.jp2                 image/jp2
*.jpe                 image/jpeg
*.jpeg               image/jpeg
*.jpg                 image/jpeg
*.js                   text/javascript, application/javascript
*.json               application/json
*.mp2               audio/mpeg, video/mpeg
*.mp3               audio/mpeg
*.mp4               audio/mp4, video/mp4
*.mpeg            video/mpeg
*.mpg              video/mpeg
*.mpp              application/vnd.ms-project
*.ogg              application/ogg, audio/ogg
*.pdf               application/pdf
*.png              image/png
*.pot               application/vnd.ms-powerpoint
*.pps              application/vnd.ms-powerpoint
*.ppt              application/vnd.ms-powerpoint
*.rtf                application/rtf, text/rtf
*.svf                image/vnd.svf
*.tif                  image/tiff
*.tiff                 image/tiff
*.txt                 text/plain
*.wdb              application/vnd.ms-works
*.wps              application/vnd.ms-works
*.xhtml            application/xhtml+xml
*.xlc                application/vnd.ms-excel
*.xlm               application/vnd.ms-excel
*.xls                application/vnd.ms-excel
*.xlt                 application/vnd.ms-excel
*.xlw               application/vnd.ms-excel
*.xml               text/xml, application/xml
*.zip                aplication/zip
*.xlsx              application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
```

### js控制文件上传选择器(注意查看兼容性)

#### [showOpenFilePicker选择文件](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/showOpenFilePicker)

```jsx
const importUserClick = async () => {
  try {
    const fileHandle = await (window as any).showOpenFilePicker({
      // 选择excel文件
      types: [{
        accept: {
          // 'image/*': ['.png', '.gif', '.jpeg', '.jpg', '.webp']
          'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
          'application/vnd.ms-excel': ['.xls']
        }
      }],
      multiple: false
    })
    // 获取File对象转为二进制文件流
    const file = await fileHandle[0].getFile()
    const arrayBuffer: any = await readFileAsArrayBuffer(file)
    const blob = new Blob([arrayBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    // 创建FormData结构传给后端
    const formData = new FormData();
    formData.append('file', blob, 'upload.xlsx');
    await importUser(formData)
    // 后续请求，更新数据
    userTableForm?.current?.getTableData()
  } catch (error) {
    console.log(error)
  }
}
```

#### [showDirectoryPicker选择文件夹](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/showDirectoryPicker)

### 文件上传导入(form-data的形式提交文件)文件上传组件借用Upload

```js
const beforeUpload = async (file?: any) => {
  let formData = new FormData(); // 创建formData
  formData.append('File', file);
  formData.append('TabName', useLevel ? 'AwardB' : 'AwardA');
  formData.append('Term', TermYear);
  formData.append('Remark', AwardRecordID + '');
  axios({
    url: baseURL + '/Document/ImportData',
    method: 'post',
    data: formData,
    headers: {
      'Content-Type': 'multipart/form-data', // multipart/form-data
      'Authorization': `X-Token={${window.location.search.split('=')[1]}}`
    }
  }).then((res) => {
    console.log(res.data);
    if (res.data.Msg === 'success') {
      if (res.data.Data.url === '') {
        Message({
          message: '文件导入成功',
          type: 'success',
          duration: 1500
        })
        getStudentsList(props.tableRowData.AwardRecordID);
        props.refreshAwardTable && props.refreshAwardTable();
      } else {
        const iframe = document.createElement('iframe');
        iframe.id = 'iframe2';
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
        iframe.src = res.data.Data.url;
        Message({
          message: '文件导入失败,具体原因请查看下载文件',
          type: 'error',
          duration: 2000
        })
      }
    } else if (res.data.Msg === '程序无法识别您所使用的模板，请尝试使用系统提供的模板') {
      useLevel ? (() => {
        Message({
          message: '导入文件模板错误，请使用正确的区分等级模板',
          type: 'error',
          duration: 2300
        })
      })() : (() => {
        Message({
          message: '导入文件模板错误，请使用正确的非等级模板',
          type: 'error',
          duration: 2300
        })
      })()
    }
  })
  return file;
}

<Upload // 借用Upload插件调用文件上传
  className="upload-demo"
  action='//jsonplaceholder.typicode.com/posts/'
  accept='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' // 参考上条
  beforeUpload={beforeUpload}
  listType='none'
>
  <LgButton
    className="lg_button_export"
    value={"导入"}
    type="default"
    showIcon
    gradient
  />
</Upload>
```


### Date转string

```js
const date = new Date();
date.toISOString(); // 天数会少一天 不行
JSON.stringify(date);

// date转string
const dateToString = (date: any) => {
  var year = date.getFullYear();
  var month = (date.getMonth() + 1).toString();
  var day = (date.getDate()).toString();
  if (month.length == 1) {
    month = "0" + month;
  }
  if (day.length == 1) {
    day = "0" + day;
  }
  var hours = date.getHours().toString();
  if (hours.length == 1) {
    hours = "0" + hours;
  }
  var mintus = date.getMinutes().toString();
  if (mintus.length == 1) {
    mintus = "0" + mintus;
  }
  var second = date.getSeconds().toString();
  if (second.length == 1) {
    second = "0" + second;
  }
  var dateTime = year + "-" + month + "-" + day + " " + hours + ":" + mintus + ":" + second;
  return dateTime;
}
```

### 后端Blob二进制文件预览与下载

* 项目中请求图片或者下载文件一般情况下都是**接口返回url或者接口本身就是一个get请求访问接口直接下载**。但是在某些情况下，**接口会返回一个二进制文件流**，在控制台打印或者network的preview中就是一串看不懂的字符串
* 接口返回的文件的二进制流，通过js的Blob对象是可以转成文件下载下来的

```ts
const fileType = getFileType(item.FileName.split('.')[item.FileName.split('.').length - 1]);
axios({
  url: `${mobxStore.ResHttpRootUrl}Download.ashx`,
  method: 'get',
  params: {
    FileUrl: item.FileUrl,
    FileName: item.FileName
  },
  headers: {
    'Authorization': `X-Token={${window.location.search.split('=')[1]}}`
  },
  responseType: 'blob'
}).then((res) => { // 拿到blob数据
  console.log(res);
  let blob = new Blob([res.data], { type: `${fileType};charset=utf-8` }); // 根据不同的文件类型转换成不同的blob
  // blob二进制文件预览
  let showFile = window.URL.createObjectURL(blob); // URL.createObjectURL可以将将blob资源转成一个地址
  window.open(showFile); // 跳转至该地址即为预览
  // blob二进制文件下载
  if ((navigator as any).msSaveBlob) {  // 如果浏览器具备
    console.log('13214214');
    (navigator as any).msSaveBlob(blob);
  } else {
    const a = document.createElement('a');
    a.href = showFile;
    a.download = item.FileName;
    a.click(); // 通过a链接点击的方式即为下载
    URL.revokeObjectURL(a.href);
    a.remove();
  }
})

const getFileType = (type: string) => {
  switch (type) {
    case 'pdf':
      return 'application/pdf'
    case 'jpeg':
      return 'image/jpeg'
    case 'jpg':
      return 'image/jpeg'
    case 'png':
      return 'image/png'
    case 'gif':
        return 'image/gif'
    case 'doc':
      return 'application/msword'
    case 'docx':
      return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    default:
      return 'text/plain'
  }
}
```



### [Blob文件流下载 type类型](https://blog.csdn.net/weixin_43550766/article/details/121991772)

#### accept类型限制直接使用'.jpg,.jpeg,.png'也可!!!

```js
let url = window.URL.createObjectURL(new Blob([文件流(一般为res.data)], { type: 'Blob类型' }))
let link = document.creatElement('a') // 创建a标签来下载
link.style.display = 'none'
link.href = url
link.setAttribute('download', '下载的文件名')
document.body.appendChild(link)
link.click()
document.body.removeChild(link)

注：在request请求中需加responseType: 'Blob'
原文链接：https://blog.csdn.net/weixin_43550766/article/details/121991772
```

### 批量处理后端返回的img图片(blob格式的文件流)，并转成url展示、多重异步处理Promise.all![vi4KtU.png](https://s1.ax1x.com/2022/07/30/vi4KtU.png)

```js
getConsultantDetail({ // 请求数据
  ConsultantID: consultantItemInfo.consultant_id
}).then(async (res) => {
  if(res.data.Data !== null && res.data.Data.Files) {
    console.log(`有${res.data.Data.Files.length}张图片`);
    // map里包含异步操作的处理
    // 使用Promnise.all包裹map返回的多个promise，注意async 与 await的使用用法
    let urls = await Promise.all(res.data.Data.Files.map(async (item: any, index: number) => { 
      return await downloadData(item);
    }))
    setImgUrlList([...urls]);
  } else {
    console.log('没有图片');
    setImgUrlList([]);
  }
})
// 
const downloadData = async (item: any): Promise<string> => {
    // console.log(res);
    // 根据不同的文件类型进行转码->blob
    let blob = new Blob([item], { type: `${fileType};charset=utf-8` }); // 根据不同的文件类型转换成不同的blob
    let url = window.URL.createObjectURL(blob); // 转成url
    urlStr = url;
}
```

### img和background-image(uri的编解码decodeURIComponent)

* **decodeURI** 只能解码 encodeURI 处理的字符串，多用于处理相对路径文件的传递
* **decodeURIComponent** 可以处理 encodeURIComponent 和 encodeURI 处理的字符串，多用于处理url图片路径这些

```css
<img src='./image/test.jpg' alt='图片加载失败' />
<img src='https://s1.ax1x.com/2022/07/30/vi4KtU.png' alt='图片加载失败' />

background-image: url('./image/test/jpg');
background-image: url(decodeURIComponent('https://s1.ax1x.com/2022/07/30/vi4KtU.png'));
```

### iframe通信相关(iframe.postMessage跨域通信与window的message消息捕获)

* #### iframe.contentWindow.postMessage

* `postMessage`方法第二个参数可以设置要发送到哪个url，如果当前子页面的url和设置的不一致，则会发送失败，我们设置为`*`，代表所有url都允许发送。

* `postMessage`方法还有第三个参数，属于高级用法，这里不做讨论，可以稍后去[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)了解。

```js
// 判断是否是iframe
const isIFrame = (input: HTMLElement | null): input is HTMLIFrameElement =>
input !== null && input.tagName === 'IFRAME';

const iframe = document.createElement('iframe');
iframe.id = 'test_iframe_message';

let addExamIframe = document.getElementById('test_iframe_message');
// react+ts中可能会报错iframe上不存在contentWindow属性，要先通过isIFrame函数判断该iframe属于HTMLIFrameElement元素，
// 再通过postMessage将数据发送出去，第二个参数代表
addExamIframe && isIFrame(addExamIframe) && addExamIframe.contentWindow?.postMessage(JSON.stringify(addExamObj), '*');
```

* #### window.addEventListener('message', handler)捕获iframe事件

```jsx
useEffect(() => {
  window.addEventListener('message', messageHandler);
}, [window])

useEffect(() => {
  return () => {
    // 移除window的message监听
    window.removeEventListener('message', messageHandler);
  }
}, [])

// 获取iframe返回的数据回调，message的监听会进到许多其他来自window的消息，注意区分即可
const messageHandler = (data: any) => {
  console.log(data);
}
```

* #### iframe向父级页面传递信息通信

```ts
const btnClick = () => {
  window.parent.postMessage(messageToParent, '*'); // 注意：'*' 表示不限制接收消息的源，出于安全考虑，你应该指定确切的源。
}

// 父级页面
useEffect(() => {
  window.addEventListener('message', messageListener);
  return () => {
    window.removeEventListener('message', messageListener);
  }
}, []);

const messageListener = (event) => {
  console.log('接收到iframe传递过来的信息', event)
}
```

* #### 其他更详细iframe通信请参考[iframe](https://blog.csdn.net/bslydhs/article/details/123473390)

### 常用使用的工具方法(utilFunctions)

```ts
import { useEffect, useRef, useState } from "react";

const moment = require('moment');

export function formatDataSize(size: number) {
  if(size >= 1073741824) {
    let integer = size / 1024;
    return integer.toFixed(1) + 'G';
  } else if (size >= 1048576) {
    let integer = size / 1024;
    return integer.toFixed(1) + 'M';
  } else {
    let integer = size / 1024;
    return integer.toFixed(1) + 'K';
  }
}

// 阿拉伯转一二三
export function toChinesNum(num: any) {
  let changeNum = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九']
  let unit = ['', '十', '百', '千', '万']
  num = parseInt(num)
  let getWan = (temp: any) => {
    let strArr = temp.toString().split('').reverse()
    let newNum = ''
    let newArr: any = []
    strArr.forEach((item: any, index: number) => {
      newArr.unshift(item === '0' ? changeNum[item] : changeNum[item] + unit[index])
    })
    let numArr: any = []
    newArr.forEach((m: any, n: any) => {
      if (m !== '零') numArr.push(n)
    })
    if (newArr.length > 1) {
      newArr.forEach((m: any, n: any) => {
        if (newArr[newArr.length - 1] === '零') {
          if (n <= numArr[numArr.length - 1]) {
            newNum += m
          }
        } else {
          newNum += m
        }
      })
    } else {
      newNum = newArr[0]
    }
    return newNum
  }
  let overWan = Math.floor(num / 10000)
  let noWan: any = num % 10000
  if (noWan.toString().length < 4) {
    noWan = '0' + noWan
  }
  return overWan ? getWan(overWan) + '万' + getWan(noWan) : (getWan(num).slice(0, 2) === '一十'? getWan(num).slice(1): getWan(num));
}

// Date转string
export function dateToString (date: any) {
  var year = date.getFullYear();
  var month = (date.getMonth() + 1).toString();
  var day = (date.getDate()).toString();
  if (month.length == 1) {
    month = "0" + month;
  }
  if (day.length == 1) {
    day = "0" + day;
  }
  var hours = date.getHours().toString();
  if (hours.length == 1) {
    hours = "0" + hours;
  }
  var mintus = date.getMinutes().toString();
  if (mintus.length == 1) {
    mintus = "0" + mintus;
  }
  var second = date.getSeconds().toString();
  if (second.length == 1) {
    second = "0" + second;
  }
  var dateTime = year + "-" + month + "-" + day + " " + hours + ":" + mintus + ":" + second;
  return dateTime;
}

// 获取最近四个学年
export function getRecentYearOptions() {
  let [ currentYear, currentMonth ] = moment().format('YYYY-MM').split('-');
  if(currentMonth[0] === '0') currentMonth = currentMonth[1];
  const yearOptions = []
  if(parseInt(currentMonth) < 9) {
    for(let i = 0; i < 4; i++) {
      yearOptions.push({
        value: `${parseInt(currentYear)-i-1}-${parseInt(currentYear)-i}`,
        label: `${parseInt(currentYear)-i-1}-${parseInt(currentYear)-i}学年`
      })
    }
  } else {
    for(let i = 0; i < 4; i++) {
      yearOptions.push({
        value: `${parseInt(currentYear)-i}-${parseInt(currentYear)-i+1}`,
        label: `${parseInt(currentYear)-i}-${parseInt(currentYear)-i+1}学年`
      })
    }
  }
  return yearOptions;
}

// 动态获取窗口宽高
interface WindowSize {
  width: number,
  height: number
}

export const useWindowSize = (): WindowSize => {
  const [windowSize, setWindowSize] = useState<WindowSize>({
    width: 0,
    height: 0
  })

  useEffect(() => {
    const handler = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      })
    }

    window.addEventListener('resize', handler);
    return () => {
      window.removeEventListener('resize', handler);
    }
  }, [])

  return windowSize;
}

// 获取setData回调的最新值
export const useSyncState: any = (state: any) => {
  const cbRef: { current: any } = useRef();
  const [data, setData] = useState(state);

  useEffect(() => {
    cbRef.current && cbRef.current(data);
  }, [data]);

  return [
    data,
    (val: any, callback: any) => {
      cbRef.current = callback;
      setData(val);
    },
  ];
};

// 获取url的各个参数：协议、主机、端口、路径
//解析URL
export function parseUrl(str:any):any{//JS正则表达式解析URL(协议/域名/端口/路径/参数/锚点)
   const options = {
      key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
      q: {
         name: "queryKey",
         parser: /(?:^|&)([^&=]*)=?([^&]*)/g
      },
      parser: {
         loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
      }
   }

   if (!str) {
      return '';
   }

   let m = options.parser.loose.exec(str) as any
   let uri = {}
   let i = 14

   while (i--) uri[options.key[i]] = m[i] || "";

   uri[options.q.name] = {};
   uri[options.key[12]].replace(options.q.parser, function (_:string, $1:string, $2:string) {
      if ($1) uri[options.q.name][$1] = $2;
   });

   return uri;
}
```

### myEvent全局事件总线

```js
class Event {
    events
    constructor() {
      this.events = {};
    }
   
    // 监听
    on(eventName, callBack) {
      if (this.events[eventName]) {
        // 存在事件
        this.events[eventName].push(callBack);
      } else {
        // 不存在事件
        this.events[eventName] = [callBack];
      }
    }
   
    // 触发
    emit(eventName, params) {
      if (this.events[eventName]) {
        this.events[eventName].map((callBack) => {
          callBack && callBack(params);
        })
      }
    }

    // 移除
    remove(eventName, callBack) {
      let _index = -1;
      if(this.events[eventName]) {
        this.events[eventName].forEach((item, index) => {
          if(item == callBack) {
            _index = index; 
          }
        })
      }
      this.events[eventName].splice(_index, 1);
    }
  }
 const myEvent = new Event()
  export default myEvent;
```



### 动态修改页面标题和icon

#### querySelector与getElementBy

* 常见的获取元素的方法有3种，分别是通过元素ID、通过标签名字和通过类名字来获取
  * document.getElementById('idName'); document.getElementsByTagName(tagName); document.getElementsByClassName('className');
* **querySelector()** 方法返回**匹配指定 CSS 选择器元素的第一个子元素** 。 该方法只返回匹配指定选择器的第一个元素。如果要返回所有匹配元素，需要使用 **querySelectorAll()** 方法替代．
* 区别：**getElementBy是动态的，当元素的内容改变了，获取的元素节点内容也随之改变**。
* querySelector是不变的。

```ts
// 动态修改图标
let titleIcon: any = document.querySelector('link[rel="icon"]');
if(titleIcon !== null) { titleIcon.href = decodeURIComponent(require('./images/123333.png')); }
// 动态修改浏览器title
// console.log(document.getElementsByTagName('title')[0]);
// let title: any = document.getElementsByTagName('title')[0];
// title.innerHTML = '心理咨询预约'; 
// 或下面的方法
let title = document.querySelector('title');
if(title !== null) { title.innerHTML = '新标题'; }
```

### div富文本显示

```js
<div dangerouslySetInnerHTML={{ __html: this.state.psychologyInformationItem.content }} className='lg_rich_text_show'></div>
```

### TypeScript针对元素(Element)的类型

### (原生js)自定义事件的触发

```js
// 创建事件
var event = document.createEvent("HTMLEvents");
// 定义事件名
event.initEvent("aaa", true, true); // 3个参数：事件类型，是否冒泡，是否阻止浏览器的默认行为
// 触发事件
window.dispatchEvent(event);

// 通过事件名监听事件的触发
window.addEventListener('aaa', function(event) {
  console.log(event.name, event.message);
}, false); // 第三个参数为false表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件。
```

### react中各组件css作用域解决方案(data-component) 最优方案(错误)!!

```jsx
function App() {
  return (
    <div className="app" data-component="app">
      <div className="content">
      </div>
    </div>
  );
}
```

```scss
[data-component=app] {
  .content {
    
  }
}
```

### iframe通信

* 父页面发送消息

```jsx
let addExamIframe = document.getElementById('lg_add_psychology_exam');
    addExamIframe && isIFrame(addExamIframe) && addExamIframe.contentWindow?.postMessage(JSON.stringify(addExamObj), '*');
```

### websocket

* websocket是一种网络通信协议，是HTML5开始提供的**在单个TCP连接上进行全双工通信的协议**，这个对比着HTTP协议来说，HTTP协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理；
* **HTTP协议无法实现服务器主动向客户端发起消息**，websocket连接**允许客户端和服务器之间**进行**全双工通信**，以便任一方都可以通过建立的连接将数据推送到另一端。websocket只需要建立一次连接，就可以一直保持连接状态；
* WebSocket使得客户端和服务器之间的数据交换变得更加简单，**允许服务端主动向客户端推送数据**。在**WebSocket API中，浏览器和服务器只需要完成一次握手**，两者之间就直接可以**创建持久性的连接**，并进行**双向数据传输**。

```javascript
// 创建websocket连接
const socket = new WebSocket('ws://localhost:3000');

// 连接成功触发
socket.addEventListener('open', function(event) {
  socket.send('Hello server');
});

// 监听消息
socket.addEventListener('message', function(event) {
  console.log('message from server', event.data);
});
```

### 淘宝镜像、cnpm

* `npm config get registry`，查看当前镜像使用的地址，返回成功，则代表设置成功
* `npm config set registry https://registry.npm.taobao.org`，切换国内镜像，使用淘宝镜像

#### cnpm

* `npm install -g cnpm --registry=https://registry.npmmirror.com`

### 普通时间字符串转时间戳

#### '2022-12-16 16:54:42' 转成时间戳：

```jsx
new Date('2022-12-16 16:54:42').getTime(); // 1671180882000

Date.parse('2022-12-16 16:54:42'); // 1671180882000
```

### 时间戳转'刚刚'、'1分钟前'、'1小时前'

```jsx
formatTimeStamp(1671180882000);
export function formatTimeStamp(timespan) {
  console.log(timespan);
  //timespan是一个时间毫秒，注意时间戳是秒的形式，在这个毫秒的基础上除以1000，就是十位数的时间戳。13位数的都是时间毫秒。
  var dateTime = new Date(timespan) // 将传进来的字符串或者毫秒转为标准时间
  var year = dateTime.getFullYear()
  var month = dateTime.getMonth() + 1
  var day = dateTime.getDate()
  var hour = dateTime.getHours()
  var minute = dateTime.getMinutes()
  var second = dateTime.getSeconds()
  // var second = dateTime.getSeconds()
  var millisecond = dateTime.getTime() // 将当前编辑的时间转换为毫秒
  var now = new Date() // 获取本机当前的时间
  var nowNew = now.getTime() // 将本机的时间转换为毫秒
  var milliseconds = 0
  var timeSpanStr
  milliseconds = nowNew - millisecond
  if (milliseconds <= 1000 * 60 * 1) { // 小于一分钟展示为刚刚
    timeSpanStr = '刚刚'
  } else if (1000 * 60 * 1 < milliseconds && milliseconds <= 1000 * 60 * 60) { // 大于一分钟小于一小时展示为分钟
    timeSpanStr = Math.round((milliseconds / (1000 * 60))) + '分钟前'
  } else if (1000 * 60 * 60 * 1 < milliseconds && milliseconds <= 1000 * 60 * 60 * 24) { // 大于一小时小于一天展示为小时
    timeSpanStr = Math.round(milliseconds / (1000 * 60 * 60)) + '小时前'
  } else if (1000 * 60 * 60 * 24 < milliseconds && milliseconds <= 1000 * 60 * 60 * 24 * 15) { // 大于一天小于十五天展示位天
    timeSpanStr = Math.round(milliseconds / (1000 * 60 * 60 * 24)) + '天前'
  } else if (milliseconds > 1000 * 60 * 60 * 24 * 15 && year === now.getFullYear()) {
    timeSpanStr = year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second
  } else {
    timeSpanStr = year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second
  }
  return timeSpanStr
}
```

### 数组方法

#### 会改变原数组的

```ts
arr.push('aaa')
arr.pop()
arr.shift()
arr.unshift('bbb')
arr.sort()
arr.reverse()
arr.splice(0, 1, 'ccc')
```

#### 不会改变原数组的

```ts
arr.split() // 返回符合条件的数组
arr.concat() // 返回连接后的数组
arr.slice() // 返回切割后的新数组
arr.forEach() // 遍历数组
arr.map() // 返回操作过item的数组
arr.some() // 判断item符合条件否，返回Boolean
```

### [浏览器获取用户地理位置(geolocation)](https://www.w3.org/TR/geolocation/#introduction)

可以通过获取到的经度(longitude)、纬度(latitude)，通过后端服务器或者调用百度、高德的sdk(software develop kit)获取位置
chrome浏览器中需要科学上网才能获取到经纬度（从chrome中获取位置信息，如果有，则使用电脑保存的地址拿到电脑ip地址，把ip地址发到google服务器），edge浏览器中（从edge中获取位置信息，如果有，则使用电脑保存的地址）

```js
function positionClick() {
  console.log('position点击')
  navigator.geolocation.getCurrentPosition(res => {
    console.log(res)
  }, err => {
    console.log(err)
  }, {
    enableHighAccuracy: true,
    timeout: 5000,
    maximumAge: 0
  })
}
```

### [dayjs使用](https://dayjs.fenxianglu.cn/)

```js
import dayjs from "dayjs";

// 获取MM/DD,具体其他使用参考官方文档
export function formatMonthDay(date) {
  return dayjs(date).format('MM月DD日')
}

// 获取间隔天数
export function getDiffDays(startDate, endDate) {
  return dayjs(endDate).diff(startDate, 'day')
}
```

### 日期格式化

```js
const date = new Date()
const year = date.getFullYear()
const month = date.getMonth() + 1
const day = date.getDate()
const nowDate: string = year + '.' + (month < 10 ? ('0' + month) : '' + month) + '.' + (day < 10? '0' + day: '' + day)
```

### 数字间隔三位加,

```js
parseFloat(123456 + '').toLocaleString() // 123,456
```

### 时间戳相关(Date方法, 非moment)

```js
Date.parse(new Date()) // 非精确
(new Date()).valueOf() // 精确
new Date().getTime() // 精确

// 日期时间转时间戳
Date.parse('2024-01-24 15:30:00') // 1706081400000
// 获取当前星期数值 1234567
(new Date()).getDay()
```

### 自动循环滚动，鼠标悬停暂停，移除继续

首先滚动的节点要先确定是存在滚动条，以下代码才生效

```js
  useEffect(() => {
    // 滚动相关
    const scrollItem = document.getElementById('auto_scroll')
    let timer: any = null
    if (scrollItem) scrollOperate(scrollItem, timer)
    return () => {
      if (scrollItem) clearOperate(scrollItem, timer)
    }
  }, [])

  // 滚动相关
  const scrollOperate = (scrollItem: HTMLElement, timer: any) => {
    // 滚动
    timer = setInterval(() => { scrollItem.scrollTop += 1 }, 25)
    scrollItem.addEventListener('scroll', scrollHandler)

    // 鼠标移入移出监听
    scrollItem.addEventListener('mouseenter', () => {
      clearInterval(timer) // 暂停滚动
      scrollItem.removeEventListener('scroll', scrollHandler) // 暂停监听滚动
    })
    scrollItem.addEventListener('mouseleave', () => {
      timer = setInterval(() => { scrollItem.scrollTop += 1 }, 25) // 继续滚动
      scrollItem.addEventListener('scroll', scrollHandler) // 继续监听滚动
      // 特殊情况：鼠标离开时滚到了底部
      if (scrollItem!.scrollTop + scrollItem!.clientHeight >= scrollItem!.scrollHeight - 0.8) {
        console.log('离开时在底部')
        scrollItem!.scrollTop = 0 // 归0重滚
      }
    })
  }

  // 触底监听
  const scrollHandler = (e: any) => {
    const scrollItem = document.getElementById('auto_scroll')
    const curScrollHeight = scrollItem!.scrollTop // 当前滚动了的高度
    const scrollBarHeight = scrollItem!.clientHeight // 滚动条高度/节点窗口高度
    const totalScrollHeight = scrollItem!.scrollHeight // 总高度
    console.log(scrollItem!.scrollTop, scrollItem!.clientHeight, scrollItem!.scrollHeight)
    if (curScrollHeight + scrollBarHeight >= totalScrollHeight - 0.8) { // -1增加容错
      console.log('滚动触底了')
      scrollItem!.scrollTop = 0 // 归0重滚
    }
  }

  // 移除相关
  const clearOperate = (scrollItem: HTMLElement | null, timer: any) => {
    if(scrollItem) {
      scrollItem.removeEventListener('scroll', scrollHandler)
      clearInterval(timer)
    }
  }
```

### 校验是否是JSON字符串

```js
export const isJsonString = (str: string) => {
  try {
    const toObj = JSON.parse(str) // json字符串转对象
    /*
        判断条件 1. 排除null可能性 
                 2. 确保数据是对象或数组
    */
    if (toObj && typeof toObj === 'object') { 
      return true
    }
  } catch {}
  return false
}
```

### exceljs结合后端模板，填入前端数据

注意区分一个excel文件和一个excel中的多个工作表

https://blog.csdn.net/baidu_41927649/article/details/135544463

![pkeCJ3Q.png](https://s21.ax1x.com/2024/05/11/pkeCJ3Q.png)

```js
import request from '@/service/request';
import ExcelJS from 'exceljs';
import dayjs from 'dayjs';

const downTemplateTable = async () => {
  const backValue: any = await request({
    url: '/beris/api/static/patterns/教辅材料.xlsx',
    method: 'GET',
    responseType: 'blob'
  });

  return backValue as Blob;
};

const returnArrayBuffer = (blob: Blob) => {
  const reader = new FileReader();

  return new Promise(
    (res: (value: ArrayBuffer) => void, rej) => {
      reader.readAsArrayBuffer(blob);
      reader.onload = (e: any) => {
        res(e.target.result);
      };
    }
  );
};

// 使用arrayBuffer
const initWorkbook = async (arrayBuffer: ArrayBuffer) => {
  // 创建一个excel
  const workbook = new ExcelJS.Workbook();

  return new Promise(
    async (
      res: (value: {
        sheet: ExcelJS.Worksheet;
        workbook: ExcelJS.Workbook;
      }) => void,
      rej
    ) => {
      // excel中加入模板数据
      const bolbLoad = await workbook.xlsx.load(
        arrayBuffer
      );

      // 创建且返回excel中的一个工作表
      const sheet = await bolbLoad.getWorksheet('情况表22');

      res({
        sheet: sheet as ExcelJS.Worksheet,
        workbook: workbook
      });
    }
  );
};

// 仅供参考，部分方法解释
const addRowToExcel = (
  sheet: ExcelJS.Worksheet,
  data: any,
  semester: string
) => {
  const titleString =
    '全省中小学(幼儿园)和中职学校XXXXXX统计表';

  const sheetTitleRow = sheet.getRow(1);
  sheetTitleRow.values = [`${titleString}  ${semester}`];
  sheet.mergeCells(
    `A${sheetTitleRow.number}:U${sheetTitleRow.number}`
  );

  sheetTitleRow.height = 39.15;
  sheetTitleRow.font = {
    name: '黑体',
    size: 12,
    bold: true
  };

  sheetTitleRow.alignment = {
    vertical: 'middle',
    horizontal: 'center',
    wrapText: false
  };

  const lastString = `注：
  1.XXXXXXXXXXXXXXXXXX等。
  2.XXXXXXXXXXXXXXXXXX“无”。     
  3.XXXXXXXXXXXXXXXXXX。 
  4.XXXXXXXXXXXXXXXXXX`;

  const typeOne = `一、“XXXXXXXXXXXXXXXXXX）`;
  const typeTwo = `二、XXXXXXXXXXXXXXXXXX`;
  const typeThree = `三、XXXXXXXXXXXXXXXXXX`;

  const { jfcl, qt, xsdw } = data;

  if (jfcl.length > 0) {
    const titleRow = sheet.addRow([typeOne]);
    sheet.mergeCells(
      `A${titleRow.number}:U${titleRow.number}`
    );
    titleRow.font = {
      name: '华文仿宋',
      size: 8,
      bold: true
    };
    titleRow.alignment = {
      vertical: 'middle',
      horizontal: 'center',
      wrapText: true
    };
    jfcl.forEach((item: any, index: number) => {
      const row = sheet.addRow(item);
      item.forEach((oo: string, i: number) => {
        row.getCell(i + 1).border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
      row.height = 30.8;
      row.font = {
        name: '宋体',
        size: 8
      };
      row.alignment = {
        vertical: 'middle',
        horizontal: 'left',
        wrapText: true
      };
    });
  }

  if (qt.length > 0) {
    const titleRow = sheet.addRow([typeTwo]);
    sheet.mergeCells(
      `A${titleRow.number}:U${titleRow.number}`
    );
    titleRow.font = {
      name: '华文仿宋',
      size: 8,
      bold: true
    };
    titleRow.alignment = {
      vertical: 'middle',
      horizontal: 'center',
      wrapText: true
    };
    qt.forEach((item: any, index: number) => {
      const row = sheet.addRow(item);
      item.forEach((oo: string, i: number) => {
        row.getCell(i + 1).border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
      row.height = 30.8;
      row.font = {
        name: '宋体',
        size: 8
      };
      row.alignment = {
        vertical: 'middle',
        horizontal: 'left',
        wrapText: true
      };
    });
  }

  if (xsdw.length > 0) {
    const titleRow = sheet.addRow([typeThree]);
    sheet.mergeCells(
      `A${titleRow.number}:U${titleRow.number}`
    );
    titleRow.font = {
      name: '华文仿宋',
      size: 8,
      bold: true
    };
    titleRow.alignment = {
      vertical: 'middle',
      horizontal: 'center',
      wrapText: true
    };
    xsdw.forEach((item: any, index: number) => {
      const row = sheet.addRow(item);
      item.forEach((oo: string, i: number) => {
        row.getCell(i + 1).border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
      row.height = 30.8;
      row.font = {
        name: '宋体',
        size: 8
      };
      row.alignment = {
        vertical: 'middle',
        horizontal: 'left',
        wrapText: true
      };
    });
  }

  // @ts-ignore
  Array.apply(null, { length: 2 }).forEach(() => {
    sheet.addRow([]);
  });

  const lastRow = sheet.addRow([lastString]);
  lastRow.height = 66.65;
  sheet.mergeCells(`A${lastRow.number}:S${lastRow.number}`);
  lastRow.font = {
    name: '黑体',
    size: 8
  };
  lastRow.alignment = {
    vertical: 'top',
    horizontal: 'left',
    wrapText: true
  };
};

// 外部文件调取DownExcel
const DownExcel = async (data: any, semester: string) => {
  // 1.获取excel模板 blob二进制文件流
  const blob = await downTemplateTable();
  // 2.blob转ArrayBuffer
  const arrayBuffer = await returnArrayBuffer(blob);
  // 3.exceljs初始化，获取workbook excel文件和内部工作表sheet
  const { sheet, workbook } = await initWorkbook(
    arrayBuffer
  );
  // 4.根据拿到的工作表sheet，将数据前端js数据填入表格中
  // 详细的插入数据方法参照exceljs相关文档
  addRowToExcel(sheet, data, semester);

  // 5.workbook excel表格转为buffer文件流
  const file = await workbook.xlsx.writeBuffer();

  // 6.文件流常规下载
  const newBlob = new Blob([file], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  });

  const url = window.URL.createObjectURL(newBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `教辅材料项目情况统计表${dayjs().format(
    'YYYYMMDDHHmmss'
  )}.xlsx`;
  document.body.appendChild(a);
  a.click();
  window.URL.revokeObjectURL(url);
  document.body.removeChild(a);
};

export default DownExcel;
```

