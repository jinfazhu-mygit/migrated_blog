"use strict";(self.webpackChunkmigrated_blog=self.webpackChunkmigrated_blog||[]).push([[556],{6262:(t,o)=>{o.A=(t,o)=>{const r=t.__vccOpts||t;for(const[t,n]of o)r[t]=n;return r}},9400:(t,o,r)=>{r.r(o),r.d(o,{comp:()=>e,data:()=>g});var n=r(641);const s={},e=(0,r(6262).A)(s,[["render",function(t,o){return(0,n.uX)(),(0,n.CE)("div",null,o[0]||(o[0]=[(0,n.Fv)('<h3 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存"><span>缓存</span></a></h3><ol><li><h3 id="dns缓存" tabindex="-1"><a class="header-anchor" href="#dns缓存"><span>DNS缓存</span></a></h3></li></ol><p>DNS(Domain Name System),即域名系统。</p><p><strong>DNS解析</strong>：通过域名，最终得到该域名对应的IP地址的过程叫做域名解析(或主机名解析)</p><p><strong>DNS缓存</strong>：有DNS的地方就有缓存。<strong>浏览器</strong>、<strong>操作系统(本地host文件)</strong>、<strong>Local DNS()</strong>、<strong>根域名服务器</strong>，他们都会对DNS结果做一定程度的缓存</p><p>DNS<strong>查询过程</strong>如下:</p><ol><li><p><strong>首先搜索浏览器自身的DNS缓存</strong>,如果存在，则域名解析到此完成。</p></li><li><p>如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取<strong>操作系统的hosts文件</strong> 看是否存在对应的映射关系,如果存在，则域名解析到此完成。</p></li><li><p>如果本地hosts文件不存在映射关系，则查找<strong>本地DNS服务器</strong>(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。</p></li><li><p>如果本地DNS服务器还没找到的话,它就会向<strong>根服务器</strong>发出请求,进行<strong>递归查询</strong>。</p></li><li><h3 id="cdn缓存" tabindex="-1"><a class="header-anchor" href="#cdn缓存"><span>CDN缓存</span></a></h3></li></ol><p><strong>什么是CDN</strong>：CDN(Content Delivery Network),即<strong>内容分发网络</strong>。</p><p>用户在浏览网站的时候，CDN会选择一个<strong>离用户最近的CDN边缘节点</strong>来响应用户的请求，这样就可以帮助用户在最近的CDN节点(缓存服务器)，用最少的时间拿到想要的资源，同时也减轻了源服务器的负载压力</p><p><strong>CDN缓存</strong>：关于CDN缓存,在<strong>浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求</strong>。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的<strong>Cache-control: max-age</strong>的字段来设置CDN边缘节点数据缓存时间。</p><p><strong>CDN缓存机制</strong>：当浏览器向CDN节点请求数据时，CDN节点会<strong>判断缓存数据是否过期</strong>，若缓存数据并<strong>没有过期，则直接将缓存数据返回给客户端</strong>；<strong>否则</strong>，CDN节点就会<strong>向服务器发出回源请求</strong>，从服务器拉取最新数据，<strong>更新本地缓存</strong>，<strong>并将最新数据返回给客户端</strong>。 CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p><ol start="3"><li><h3 id="浏览器缓存-http缓存" tabindex="-1"><a class="header-anchor" href="#浏览器缓存-http缓存"><span>浏览器缓存(http缓存)</span></a></h3></li></ol><p><strong>流程</strong>：简单来说,浏览器缓存其实就是<strong>浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为</strong>。</p><figure><img src="https://z3.ax1x.com/2021/08/28/h1YaQI.png" alt="h1YaQI.png" tabindex="0" loading="lazy"><figcaption>h1YaQI.png</figcaption></figure><p>​ (图片重要!!!)</p><p><strong>缓存的资源在哪里</strong>：</p><ol><li><strong>memory cache</strong>:MemoryCache顾名思义，就是将<strong>资源缓存到内存</strong>中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。 <strong>目前Webkit资源分成两类</strong>，一类是<strong>主资源</strong>，比如<strong>HTML页面，或者下载项</strong>，一类是<strong>派生资源</strong>，比<strong>如HTML页面中内嵌的图片或者脚本链接</strong>，分别对应代码中两个类：MainResourceLoader和SubresourceLoader。虽然Webkit支持<strong>memoryCache，但是也只是针对派生资源</strong>，它对应的类为CachedResource，用于保存原始数据（比如JS等），以及解码过的图片数据。</li><li><strong>disk cache</strong>:DiskCache顾名思义，就是<strong>将资源缓存到磁盘</strong>中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为CurlCacheManager。</li><li><strong>三级缓存原理(访问缓存优先级)</strong><ol><li><strong>先在内存中查找</strong>,如果有,直接加载。(MemoryCache)刷新页面走的是Memory Cache</li><li>如果内存中不存在,则<strong>在硬盘中查找</strong>,如果有直接加载。(disk cache),重新打开页面走的是disk cache,</li><li>如果硬盘中也没有,那么就进行<strong>网络请求</strong>。(http)</li><li><strong>请求获取的资源缓存到硬盘和内存</strong>。</li></ol></li></ol><p><strong>浏览器缓存的分类</strong>: <strong>强缓存、协商缓存</strong>，浏览器在向服务器请求资源时，<strong>首先判断是否命中强缓存，再判断是否命中协商缓存</strong>。</p><p><strong>浏览器强缓存(本地缓存是否过期)</strong>：浏览器在加载资源时，会先根据<strong>本地缓存资源的 header</strong> 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。这里的 <strong>header</strong> 中的信息指的是 <strong>expires</strong> 和 <strong>cahe-control</strong>.</p><p>​ <strong>expires</strong>：该字段是http1.0时的规范，它的值为一个绝对时间的GMT时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间<strong>代表着这个资源的失效时间</strong>，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以<strong>当服务器与客户端时间偏差较大时，就会导致缓存混乱。</strong></p><p>​ <strong>Cache-Control(重要)</strong>：Cache-Control 是 <strong>http1.1</strong> 时出现的 header 信息，主要是利用该字段的 <strong>max-age</strong> 值来进行判断，它是一个<strong>相对时间</strong>，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：</p><p>​ <strong>no-cache</strong>：需要进行协商缓存，发送请求到服务器确认是否使用缓存。</p><p>​ <strong>no-store</strong>：禁止使用缓存，每一次都要重新请求数据。</p><p>​ <strong>public</strong>：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。</p><p>​ <strong>private</strong>：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。</p><p>​ <strong>Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。</strong></p><p><strong>协商缓存(本地强缓存过期，服务器端判断是否有更新)</strong>：当<strong>强缓存没有命中</strong>的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断<strong>是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新</strong>，可使用本地的缓存。</p><p>​ <strong>Last-Modify/If-Modify-Since</strong></p><p>​ 浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 <strong>Last-Modify</strong>，Last-modify 是一个 时间标识该资源的最后修改时间。</p><p>​ 当浏览器再次请求该资源时，<strong>request 的请求头中会包含 If-Modify-Since</strong>，该值为缓存之前返回的Last-Modify。服务器收到 If-Modify-Since 后，<strong>根据资源 的最后修改时间判断是否命中缓存</strong>。</p><p>​ 如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。</p><p>​ 缺点:</p><p>​ 短时间内资源发生了改变，Last-Modified 并不会发生变化。</p><p>​ 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为,因此便有了 ETag。</p><p>​ <strong>ETag/If-None-Match(重要)</strong></p><p>​ 与 Last-Modify/If-Modify-Since 不同的是，Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，<strong>资源变化都会导致 ETag 变化</strong>。服务器根据浏览器上送的 <strong>If-None-Match</strong> 值来判断是否命中缓存。</p><p>​ 与 Last-Modified 不一样的是，当服务器返回 <strong>304 Not Modified</strong> 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</p><p>​ <strong>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</strong></p><p>参考链接：<a href="https://juejin.cn/post/6844903764566999054" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903764566999054</a></p><p>作者：null仔 来源：掘金</p>',40)]))}]]),g=JSON.parse('{"path":"/posts/blogs/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3","title":"缓存相关","lang":"zh-CN","frontmatter":{"title":"缓存相关","date":"2021-08-28T15:00:00.000Z","permalink":"/posts/blogs/缓存相关","isTimeLine":true,"category":["我的前端路线"],"tag":["浏览器缓存"],"icon":"pen-to-square","star":true,"sticky":true,"description":"缓存 DNS缓存 DNS(Domain Name System),即域名系统。 DNS解析：通过域名，最终得到该域名对应的IP地址的过程叫做域名解析(或主机名解析) DNS缓存：有DNS的地方就有缓存。浏览器、操作系统(本地host文件)、Local DNS()、根域名服务器，他们都会对DNS结果做一定程度的缓存 DNS查询过程如下: 首先搜索浏览器自...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"缓存相关\\",\\"image\\":[\\"https://z3.ax1x.com/2021/08/28/h1YaQI.png\\"],\\"datePublished\\":\\"2021-08-28T15:00:00.000Z\\",\\"dateModified\\":\\"2025-07-03T11:15:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"zzf\\",\\"url\\":\\"https://mister-hope.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/migrated_blog/posts/blogs/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"缓存相关"}],["meta",{"property":"og:description","content":"缓存 DNS缓存 DNS(Domain Name System),即域名系统。 DNS解析：通过域名，最终得到该域名对应的IP地址的过程叫做域名解析(或主机名解析) DNS缓存：有DNS的地方就有缓存。浏览器、操作系统(本地host文件)、Local DNS()、根域名服务器，他们都会对DNS结果做一定程度的缓存 DNS查询过程如下: 首先搜索浏览器自..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://z3.ax1x.com/2021/08/28/h1YaQI.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-03T11:15:49.000Z"}],["meta",{"property":"article:tag","content":"浏览器缓存"}],["meta",{"property":"article:published_time","content":"2021-08-28T15:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-03T11:15:49.000Z"}]]},"git":{"createdTime":1751541349000,"updatedTime":1751541349000,"contributors":[{"name":"zhujinfa","username":"zhujinfa","email":"2095229306@qq.com","commits":1,"url":"https://github.com/zhujinfa"}]},"readingTime":{"minutes":6.84,"words":2052},"filePathRelative":"posts/blogs/缓存相关.md","excerpt":"<h3>缓存</h3>\\n<ol>\\n<li>\\n<h3>DNS缓存</h3>\\n</li>\\n</ol>\\n<p>DNS(Domain Name System),即域名系统。</p>\\n<p><strong>DNS解析</strong>：通过域名，最终得到该域名对应的IP地址的过程叫做域名解析(或主机名解析)</p>\\n<p><strong>DNS缓存</strong>：有DNS的地方就有缓存。<strong>浏览器</strong>、<strong>操作系统(本地host文件)</strong>、<strong>Local DNS()</strong>、<strong>根域名服务器</strong>，他们都会对DNS结果做一定程度的缓存</p>","autoDesc":true}')}}]);