"use strict";(self.webpackChunkmigrated_blog=self.webpackChunkmigrated_blog||[]).push([[9433],{861:(s,i,e)=>{e.r(i),e.d(i,{comp:()=>l,data:()=>t});var a=e(641);const n={},l=(0,e(6262).A)(n,[["render",function(s,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h1 id="样式隔离方案" tabindex="-1"><a class="header-anchor" href="#样式隔离方案"><span>样式隔离方案</span></a></h1><blockquote><p>本文主要讲css各种解决方案，包括，<code>BEM</code>、<code>css modules</code>、<code>Css in Js</code>、<code>预处理器</code>、<code>Shadow DOM</code>，<code>Vue Scoped</code>通过分析各项方案的<strong>产生背景、带来的好处以及存在的一些问题</strong>来帮助大家判断自己的<code>项目中适合使用哪种那方案</code></p></blockquote><figure><img src="https://s1.ax1x.com/2022/10/21/x6Xvhd.png" alt="x6Xvhd.png" tabindex="0" loading="lazy"><figcaption>x6Xvhd.png</figcaption></figure><ul><li>BEM：样式类名命名思想</li><li>CSS Modules：<strong>className={style.title}</strong>，依赖于css-loader</li><li>CSS in JS： <ul><li><strong>styled-components</strong>：<strong>const StyleDom = styled.div``</strong>；</li><li>Radium：<strong>style.classname</strong> 全<strong>转为内联样式(行内样式)</strong>；</li></ul></li><li>预处理器：<strong>scss、sass、less、Stylus、PostCSS</strong></li><li>Shadow DOM</li><li>vue scoped</li></ul><h2 id="一、bem" tabindex="-1"><a class="header-anchor" href="#一、bem"><span>一、BEM</span></a></h2><h3 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h3><p>BEM是<code>一种css命名方法论</code>，意思是块（Block）、元素（Element）、修饰符（Modifier）的简写</p><p>这种命名方法让CSS便于统一团队开发规范和方便维护</p><p>以 <code>.block__element--modifier</code>或者说<code>block-name__element-name--modifier-name</code>形式命名，命名有含义，也就是<code>模块名 + 元素名 + 修饰器名</code></p><p>社区里面对BEM命名的褒贬不一，但是对其的思想基本上还是认同的，所以<strong>可以用它的思想</strong>，<strong>不一定要用它的命名方式</strong></p><h4 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h4><p>BEM思想通常用于<code>组件库</code>，业务代码中<code>结合less等预处理器</code></p><h4 id="优缺点分析" tabindex="-1"><a class="header-anchor" href="#优缺点分析"><span>优缺点分析</span></a></h4><p><strong>优点</strong></p><ol><li>可读性高，可维护性高</li></ol><p><strong>缺点</strong></p><ol><li>命名太长(不算缺点，提高了代码的可读性)，体积增大，gzip可忽略</li></ol><h2 id="二、css-modules-依赖于css-loader" tabindex="-1"><a class="header-anchor" href="#二、css-modules-依赖于css-loader"><span>二、CSS modules(依赖于css-loader)</span></a></h2><h3 id="简介-1" tabindex="-1"><a class="header-anchor" href="#简介-1"><span>简介</span></a></h3><p>什么是<code>CSS Modules</code>？</p><p>顾名思义，<code>css-modules 将 css 代码模块化</code>，可以避免<code>本模块样式被污染</code>，并且可以很方便的复用 css 代码</p><p>根据<code>CSS Modules</code>在Gihub上的<a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener noreferrer">项目</a>，它被解释为：</p><blockquote><p>所有的类名和动画名称默认都有各自的作用域的CSS文件。</p></blockquote><p>所以<code>CSS Modules</code>既不是官方标准，也不是浏览器的特性，而是<strong>在构建步骤（例如使用Webpack，记住css-loader）中对CSS类名和选择器限定作用域的一种方式</strong>（类似于命名空间）</p><p>依赖<code>webpack css-loader</code>，配置如下，现在webpack已经默认开启CSS modules功能了scss,sass类似</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-css"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    test: /.css$/,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    loader: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;style-loader!css-loader?modules&quot;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们先看一个<strong>示例：</strong></p><p>将<code>CSS</code>文件<code>style.css</code>引入为<code>style</code>对象后，通过<code>style.title</code>的方式使用<code>title class</code>：</p><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-jsx"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> style</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;./style.css&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;"> default</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> className</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">title</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; // 通过style.类名，给元素添加样式</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      I am KaSong.</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  );</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应<code>style.css</code>：</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-css"><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.title</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">red</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>打包工具会将<code>style.title</code>编译为<code>带哈希的字符串</code></p><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-jsx"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> class</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;_3zyde4l1yATCOkgn-DBWEL&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  Hello World</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时<code>style.css</code>也会编译：</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-css"><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">._3zyde4l1yATCOkgn-DBWEL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">red</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，就产生了独一无二的<code>class</code>，解决了<code>CSS</code>模块化的问题</p><p>使用了 CSS Modules 后，就相当于给每个 class 名外加加了一个 <code>:local</code>，以此来实现样式的局部化，如果你想切换到全局模式，使用对应的 <code>:global</code>。</p><p><code>:local</code> 与 <code>:global</code> 的区别是 <strong>CSS Modules 只会对 <code>:local</code> 块的 class 样式做 <code>localIdentName</code> 规则处理，<code>:global</code> 的样式编译后不变</strong></p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-css"><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.title</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">red</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:global(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.title</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) { color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">green</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，依旧使用CSS，但使用JS来管理样式依赖， 最大化地结合现有 CSS 生态和 JS 模块化能力，发布时依旧编译出单独的 JS 和 CSS</p><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h3><p><strong>优点</strong></p><ul><li>能100%解决css无作用域样式污染问题</li><li>学习成本低：API简洁到几乎零学习成本</li></ul><p><strong>缺点</strong></p><ul><li>写法没有传统开发流程，如果你不想频繁的输入 <code>styles.**</code>，可以试一下 [react-css-modules](<a href="https://link.zhihu.com/?target=https%3A//github.com/gajus/react-css-modules" target="_blank" rel="noopener noreferrer">gajus/react-css-modules · GitHub</a>)，它通过高阶函数的形式来避免重复输入 <code>styles.**</code></li><li>没有变量，通常要结合预处理器</li><li>代码可读性差，hash值不方便debug</li></ul><p>css modules通常结合less等预处理器在react中使用，更多可参考<a href="https://zhuanlan.zhihu.com/p/20495964" target="_blank" rel="noopener noreferrer">CSS Modules 详解及 React 中实践</a></p><h2 id="三、css-in-js-styled-components、radium" tabindex="-1"><a class="header-anchor" href="#三、css-in-js-styled-components、radium"><span>三、CSS in JS(styled-components、Radium)</span></a></h2><h3 id="简介-2" tabindex="-1"><a class="header-anchor" href="#简介-2"><span>简介</span></a></h3><p><code>CSS in JS</code>是2014年推出的一种<strong>设计模式</strong>，它的核心思想是<code>把CSS直接写到各自组件中</code>，也就是说<code>用JS去写CSS</code>，而不是单独的样式文件里</p><p>这跟传统的前端开发思维不一样，传统的原则是<code>关注点分离</code>，如常说的<code>不写行内样式</code>、<code>不写行内脚本</code>，如下代码</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-html"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">color:red;font-size:46px;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  onclick</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">alert</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;Hi&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">)</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  Hello World</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>CSS-in-JS</code>不是一种很新的技术，可是它在国内普及度好像并不是很高，它当初的出现是因为一些<code>component-based</code>的<code>Web</code>框架（例如 <code>React</code>，<code>Vue</code> 和 <code>Angular</code>）的逐渐流行，使得开发者也想<code>将组件的CSS样式也一块封装到组件中去</code>以<strong>解决原生CSS写法的一系列问题</strong></p><blockquote><p>CSS-in-JS在<code>React社区</code>的热度是最高的，这是因为React本身不会管用户怎么去为组件定义样式的问题，而Vue和Angular都有属于框架自己的一套定义样式的方案</p></blockquote><p>上面的例子使用 <code>React</code> 改写如下</p><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-jsx"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> style</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &#39;color&#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;red&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>\n<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &#39;fontSize&#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;46px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> clickHandler</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> alert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;hi&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">ReactDOM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">render</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> style</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> onclick</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">clickHandler</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">     Hello, world!</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getElementById</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;example&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码在一个文件里面，封装了<strong>结构、样式和逻辑</strong>，完全<code>违背了&quot;关注点分离&quot;的原则</code></p><p>但是，这<code>有利于组件的隔离</code>。每个组件包含了所有需要用到的代码，不依赖外部，组件之间没有耦合，很方便复用。所以，随着 React 的走红和组件模式深入人心，这种&quot;<code>关注点混合</code>&quot;的新写法逐渐成为主流</p><h3 id="实现css-in-js的库汇总" tabindex="-1"><a class="header-anchor" href="#实现css-in-js的库汇总"><span>实现CSS in JS的库汇总</span></a></h3><p>实现了<code>CSS-in-JS</code>的库有很多，<a href="https://link.zhihu.com/?target=https%3A//github.com/MicheleBertoli/css-in-js" target="_blank" rel="noopener noreferrer">据统计</a>现在已经超过了61种。虽然每个库解决的问题都差不多，可是它们的实现方法和语法却大相径庭</p><p>从实现方法上区分大体分为两种：</p><ul><li><code>唯一CSS选择器</code>，代表库：<a href="https://github.com/styled-components/styled-components" target="_blank" rel="noopener noreferrer">styled-components</a></li><li><code>内联样式</code>（Unique Selector VS Inline Styles）</li></ul><p>不同的<code>CSS in JS</code>实现除了生成的<code>CSS样式和编写语法</code>有所区别外，它们实现的功能也不尽相同，除了一些最基本的诸如CSS局部作用域的功能，下面这些功能有的实现会包含而有的却不支持：</p><ul><li>自动生成浏览器引擎前缀 - built-in vendor prefix</li><li>支持抽取独立的CSS样式表 - extract css file</li><li>自带支持动画 - built-in support for animations</li><li>伪类 - pseudo classes</li><li>媒体查询 - media query</li><li>其他</li></ul><h3 id="styled-components示例-也可查看react脚手架组件化开发blog" tabindex="-1"><a class="header-anchor" href="#styled-components示例-也可查看react脚手架组件化开发blog"><span><a href="https://github.com/styled-components/styled-components" target="_blank" rel="noopener noreferrer">styled-components</a>示例(也可查看react脚手架组件化开发blog)</span></a></h3><p><a href="https://github.com/styled-components/styled-components" target="_blank" rel="noopener noreferrer">Styled-components</a> 是<code>CSS in JS</code>最热门的一个库了，到目前为止github的star数已经超过了<code>35k</code></p><p>通过<code>styled-components</code>，可以使用ES6的<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener noreferrer">标签模板字符串</a>语法（Tagged Templates）为需要<code>styled</code>的<code>Component</code>定义一系列<code>CSS</code>属性</p><p>当该组件的<code>JS代码被解析执行</code>的时候，<code>styled-components会动态生成一个CSS选择器</code>，并把对应的<code>CSS</code>样式通过<code>style</code>标签的形式插入到<code>head</code>标签里面。动态生成的<code>CSS</code>选择器会有一小段<code>哈希值来保证全局唯一性</code>来避免样式发生冲突</p><p><a href="https://link.zhihu.com/?target=https%3A//www.cssinjsplayground.com/" target="_blank" rel="noopener noreferrer">CSS-in-JS Playground</a>是一个可以快速尝试不同CSS-in-JS实现的网站，上面有一个简单的用<code>styled-components</code>实现表单的例子；</p><figure><img src="https://s1.ax1x.com/2022/10/21/x6qhtA.png" alt="x6qhtA.png" tabindex="0" loading="lazy"><figcaption>x6qhtA.png</figcaption></figure><p><code>styled-components</code>不需要你为需要设置样式的DOM节点设置一个<code>样式名</code>，使用完标签模板字符串定义后你会得到一个<code>styled</code>好的<code>Component</code>，直接在<code>JSX</code>中使用这个<code>Component</code>就可以了</p><h3 id="radium示例" tabindex="-1"><a class="header-anchor" href="#radium示例"><span><a href="https://formidable.com/open-source/radium/" target="_blank" rel="noopener noreferrer">Radium</a>示例</span></a></h3><p><code>Radium</code>和<code>styled-components</code>的最大区别是它生成的是<code>标签内联样式（inline styles）</code></p><p>由于标签内联样式在处理诸如<code>media query</code>以及<code>:hover</code>，<code>:focus</code>，<code>:active</code>等和浏览器状态相关的样式的时候非常不方便，所以<code>radium</code>为这些样式封装了一些标准的接口以及抽象</p><p>再来看一下<code>radium</code>在<a href="https://www.cssinjsplayground.com/?activeModule=index&amp;library=radium" target="_blank" rel="noopener noreferrer">CSS-in-JS Playground</a>的例子：</p><figure><img src="https://s1.ax1x.com/2022/10/21/x6qL7Q.png" alt="x6qL7Q.png" tabindex="0" loading="lazy"><figcaption>x6qL7Q.png</figcaption></figure><p>从上面的例子可以看出<code>radium</code>定义样式的语法和<code>styled-components</code>有很大的区别，它要求你<strong>使用<code>style</code>属性为<code>DOM</code>添加相应的样式</strong></p><p><strong>直接在标签内生成内联样式</strong>，内联样式相比于CSS选择器的方法有以下的优点： <code>自带局部样式作用域的效果</code>，无需额外的操作</p><h3 id="css-in-js-与-css-预处理器-比如-less-和-sass-包括-postcss-有什么区别" tabindex="-1"><a class="header-anchor" href="#css-in-js-与-css-预处理器-比如-less-和-sass-包括-postcss-有什么区别"><span>CSS in JS 与&quot;CSS 预处理器&quot;（比如 Less 和 <a href="https://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener noreferrer">Sass</a>，包括 PostCSS）有什么区别</span></a></h3><p><code>CSS in JS</code> 使用 <code>JavaScript</code> 的语法，<strong>是 JavaScript 脚本的一部分</strong>，不用从头学习一套专用的 API，也不会多一道编译步骤，但是通常会在运行时动态生成CSS，造成一定运行时开销</p><h3 id="优缺点分析-1" tabindex="-1"><a class="header-anchor" href="#优缺点分析-1"><span>优缺点分析</span></a></h3><p><strong>优点</strong></p><ul><li><p><strong>没有无作用域问题样式污染问题</strong></p><p>通过唯一CSS选择器或者行内样式解决</p></li><li><p><strong>没有无用的CSS样式堆积问题</strong></p><p>CSS-in-JS会把样式和组件绑定在一起，当这个组件要被删除掉的时候，直接把这些代码删除掉就好了，不用担心删掉的样式代码会对项目的其他组件样式产生影响。而且由于CSS是写在JavaScript里面的，我们还可以利用JS显式的变量定义，模块引用等语言特性来追踪样式的使用情况，这大大方便了我们对样式代码的更改或者重构</p></li><li><p><strong>更好的基于状态的样式定义</strong></p><p>CSS-in-JS会直接将CSS样式写在JS文件里面，所以样式复用以及逻辑判断都十分方便</p></li></ul><p><strong>缺点</strong></p><ul><li><p><strong>一定的学习成本</strong></p></li><li><p><strong>代码可读性差</strong></p><p>大多数CSS-in-JS实现会通过生成唯一的CSS选择器来达到CSS局部作用域的效果。这些自动生成的选择器会大大降低代码的可读性，给开发人员debug造成一定的影响</p></li><li><p><strong>运行时消耗</strong></p><p>由于大多数的CSS-in-JS的库都是在动态生成CSS的。这会有两方面的影响。首先你发送到客户端的代码会包括使用到的CSS-in-JS运行时（runtime）代码，这些代码一般都不是很小，例如styled-components的runtime大小是<code>12.42kB min + gzip</code>，如果你希望你首屏加载的代码很小，你得考虑这个问题。其次大多数CSS-in-JS实现都是在客户端动态生成CSS的，这就意味着会有一定的性能代价。不同的CSS-in-JS实现由于具体的实现细节不一样，所以它们的性能也会有很大的区别，你可以通过<a href="https://link.zhihu.com/?target=http%3A//necolas.github.io/react-native-web/benchmarks/" target="_blank" rel="noopener noreferrer">这个工具</a>来查看和衡量各个实现的性能差异</p></li><li><p>不能结合成熟的CSS预处理器（或后处理器）Sass/Less/PostCSS，<code>:hover</code> 和 <code>:active</code> 伪类处理起来复杂</p></li></ul><blockquote><p>可以看到优点多，缺点也不少，选择需慎重，更多可阅读阮一峰老师写的<a href="http://www.ruanyifeng.com/blog/2017/04/css_in_js.html" target="_blank" rel="noopener noreferrer">CSS in JS简介</a>，<a href="https://zhuanlan.zhihu.com/p/103522819" target="_blank" rel="noopener noreferrer">知乎CSS in JS的好与坏</a></p></blockquote><h2 id="四、预处理器" tabindex="-1"><a class="header-anchor" href="#四、预处理器"><span>四、预处理器</span></a></h2><h3 id="简介-3" tabindex="-1"><a class="header-anchor" href="#简介-3"><span>简介</span></a></h3><p><strong>CSS 预处理器</strong>是一个能让你通过预处理器自己独有的语法的程序</p><p>市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器<strong>会增加一些原生CSS不具备的特性</strong>，例如</p><ul><li>代码混合</li><li>嵌套选择器</li><li>继承选择器</li></ul><p>这些特性让CSS的结构<code>更加具有可读性且易于维护</code></p><p>要使用CSS预处理器，你必须在web服务中安装CSS<code>编译工具</code></p><p>我们常见的预处理器：</p><ul><li><strong><a href="https://sass-lang.com/" target="_blank" rel="noopener noreferrer">Sass</a></strong></li><li><strong><a href="https://lesscss.org/" target="_blank" rel="noopener noreferrer">LESS</a></strong></li><li><strong><a href="http://stylus-lang.com/" target="_blank" rel="noopener noreferrer">Stylus</a></strong></li><li><strong><a href="http://postcss.org/" target="_blank" rel="noopener noreferrer">PostCSS</a></strong></li></ul><h3 id="优缺点分析-2" tabindex="-1"><a class="header-anchor" href="#优缺点分析-2"><span>优缺点分析</span></a></h3><p><strong>优点</strong></p><ol><li>利用嵌套，人为严格遵守嵌套首类名不一致，可以解决无作用域样式污染问题</li><li>可读性好，一目了然是那个dom节点，对于无用css删除，删除了相应dom节点后，对应的css也能比较放心的删除，不会影响到其他元素样式</li></ol><p><strong>缺点</strong></p><ol><li>需要借助相关的编译工具处理</li></ol><blockquote><p>预处理器是现代web开发中必备，<code>结合BEM规范</code>，利用预处理器，可以极大的<code>提高开发效率，可读性，复用性</code></p></blockquote><h2 id="五、shadow-dom" tabindex="-1"><a class="header-anchor" href="#五、shadow-dom"><span>五、Shadow DOM</span></a></h2><h3 id="简介-4" tabindex="-1"><a class="header-anchor" href="#简介-4"><span>简介</span></a></h3><p>熟悉<code>web Components</code>的一定知道<code>Shadow DOM</code>可以实现样式隔离，由浏览器原生支持</p><figure><img src="https://s1.ax1x.com/2022/10/21/x6XeOK.png" alt="x6XeOK.png" tabindex="0" loading="lazy"><figcaption>x6XeOK.png</figcaption></figure><p>我们经常在微前端领域看到<code>Shadow DOM</code>，如下创建一个子应用</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> shadow</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">querySelector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;#hostElement&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">attachShadow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">mode</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;open&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">shadow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">innerHTML</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;&lt;sub-app&gt;Here is some new text&lt;/sub-app&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//unpkg.com/antd/antd.min.css&quot;&gt;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于子应用的样式作用域仅在 <code>shadow</code> 元素下，那么一旦子应用中出现运行时越界跑到外面构建 DOM 的场景，必定会导致构建出来的 DOM 无法应用子应用的样式的情况。</p><p>比如 <code>sub-app</code> 里调用了 <code>antd modal</code> 组件，由于 <code>modal</code> 是动态挂载到 <code>document.body</code> 的，而由于 <code>Shadow DOM</code> 的特性 <code>antd</code> 的样式只会在 <code>shadow</code> 这个作用域下生效，结果就是弹出框无法应用到 <code>antd</code> 的样式。解决的办法是把 <code>antd</code> 样式上浮一层，丢到主文档里，但这么做意味着子应用的样式直接泄露到主文档了</p><h3 id="优缺点分析-3" tabindex="-1"><a class="header-anchor" href="#优缺点分析-3"><span>优缺点分析</span></a></h3><p><strong>优点</strong></p><ul><li>浏览器原生支持</li><li>严格意义上的样式隔离，如iframe一样</li></ul><p><strong>缺点</strong></p><ul><li>浏览器兼容问题</li><li>只对一定范围内的dom结构起作用，上面微前端场景已经说明</li></ul><blockquote><p>普通业务开发我们还是用框架、如Vue、React；Shadow DOM适用于特殊场景，如微前端</p></blockquote><h2 id="六、vue-scoped" tabindex="-1"><a class="header-anchor" href="#六、vue-scoped"><span>六、vue scoped</span></a></h2><p>当 <code>&lt;style&gt;</code> 标签有 <code>scoped</code> 属性时，它的 <code>CSS</code> 只作用于当前组件中的元素</p><p>通过使用 <strong><code>PostCSS</code></strong> 来实现以下转换：</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-vue"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> scoped</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.example</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">red</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;example&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;hi&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换结果：</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-vue"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.example</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">data-v-f3f3eg9</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">red</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;example&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> data-v-f3f3eg9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;hi&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>scoped</code> 后，<strong>父组件的样式将不会渗透到子组件中</strong></p><p>不过一个<strong>子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响</strong>。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式，父租价利用<code>深度作用选择器</code>影响子组件样式</p><p>可以使用 <code>&gt;&gt;&gt;</code> 操作符：</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-vue"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> scoped</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.a</span><span style="--shiki-light:#000000;--shiki-dark:#FFFFFF;"> &gt;&gt;&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> .b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* ... */</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码将会编译成：</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-vue"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.a[data-v-f3f3eg9] .b { /* ... */ }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>有些像 <code>Sass</code> 之类的预处理器无法正确解析 <code>&gt;&gt;&gt;</code>。这种情况下你可以使用 <code>/deep/</code> 或 <code>::v-deep</code> 操作符取而代之——两者都是 <code>&gt;&gt;&gt;</code> 的别名，同样可以正常工作</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>六种方案对比如下，社区通常的样式隔离方案，以下两种</p><ul><li><code>BEM+预处理器</code></li><li><code>CSS Moduls + 预处理器</code></li></ul><figure><img src="https://s1.ax1x.com/2022/10/21/x6Xvhd.png" alt="x6Xvhd.png" tabindex="0" loading="lazy"><figcaption>x6Xvhd.png</figcaption></figure>',131)]))}]]),t=JSON.parse('{"path":"/posts/blogs/CSS%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB%E6%96%B9%E6%A1%88","title":"CSS样式隔离方案","lang":"zh-CN","frontmatter":{"title":"CSS样式隔离方案","date":"2022-10-21T15:20:00.000Z","permalink":"/posts/blogs/CSS样式隔离方案","isTimeLine":true,"category":["我的前端路线"],"tag":["html,css","sass"],"icon":"pen-to-square","star":true,"sticky":true,"description":"样式隔离方案 本文主要讲css各种解决方案，包括，BEM、css modules、Css in Js、预处理器、Shadow DOM，Vue Scoped通过分析各项方案的产生背景、带来的好处以及存在的一些问题来帮助大家判断自己的项目中适合使用哪种那方案 x6Xvhd.pngx6Xvhd.png BEM：样式类名命名思想 CSS Modules：cla...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CSS样式隔离方案\\",\\"image\\":[\\"https://s1.ax1x.com/2022/10/21/x6Xvhd.png\\",\\"https://s1.ax1x.com/2022/10/21/x6qhtA.png\\",\\"https://s1.ax1x.com/2022/10/21/x6qL7Q.png\\",\\"https://s1.ax1x.com/2022/10/21/x6XeOK.png\\",\\"https://s1.ax1x.com/2022/10/21/x6Xvhd.png\\"],\\"datePublished\\":\\"2022-10-21T15:20:00.000Z\\",\\"dateModified\\":\\"2025-07-03T11:15:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/migrated_blog/posts/blogs/CSS%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB%E6%96%B9%E6%A1%88"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"CSS样式隔离方案"}],["meta",{"property":"og:description","content":"样式隔离方案 本文主要讲css各种解决方案，包括，BEM、css modules、Css in Js、预处理器、Shadow DOM，Vue Scoped通过分析各项方案的产生背景、带来的好处以及存在的一些问题来帮助大家判断自己的项目中适合使用哪种那方案 x6Xvhd.pngx6Xvhd.png BEM：样式类名命名思想 CSS Modules：cla..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://s1.ax1x.com/2022/10/21/x6Xvhd.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-03T11:15:49.000Z"}],["meta",{"property":"article:tag","content":"sass"}],["meta",{"property":"article:tag","content":"html,css"}],["meta",{"property":"article:published_time","content":"2022-10-21T15:20:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-03T11:15:49.000Z"}]]},"git":{"createdTime":1751541349000,"updatedTime":1751541349000,"contributors":[{"name":"zhujinfa","username":"zhujinfa","email":"2095229306@qq.com","commits":1,"url":"https://github.com/zhujinfa"}]},"readingTime":{"minutes":12.71,"words":3812},"filePathRelative":"posts/blogs/CSS样式隔离方案.md","excerpt":"\\n<blockquote>\\n<p>本文主要讲css各种解决方案，包括，<code>BEM</code>、<code>css modules</code>、<code>Css in Js</code>、<code>预处理器</code>、<code>Shadow DOM</code>，<code>Vue Scoped</code>通过分析各项方案的<strong>产生背景、带来的好处以及存在的一些问题</strong>来帮助大家判断自己的<code>项目中适合使用哪种那方案</code></p>\\n</blockquote>\\n<figure><img src=\\"https://s1.ax1x.com/2022/10/21/x6Xvhd.png\\" alt=\\"x6Xvhd.png\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>x6Xvhd.png</figcaption></figure>","autoDesc":true}')},6262:(s,i)=>{i.A=(s,i)=>{const e=s.__vccOpts||s;for(const[s,a]of i)e[s]=a;return e}}}]);